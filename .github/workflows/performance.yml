name: Performance Testing & Health Monitoring

on:
  schedule:
    # Run performance tests daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Type of performance test to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - api_only
          - database_only
          - load_test

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  pipeline-performance-check:
    name: Pipeline Performance Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: Record pipeline start time
        id: start_time
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Cache cargo dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-perf-${{ hashFiles('**/Cargo.lock') }}

      - name: Build release (performance test)
        run: cargo build --release --verbose

      - name: Calculate pipeline duration
        id: duration
        run: |
          start_time=${{ steps.start_time.outputs.start_time }}
          end_time=$(date +%s)
          duration=$((end_time - start_time))
          duration_minutes=$((duration / 60))
          echo "duration_seconds=$duration" >> $GITHUB_OUTPUT
          echo "duration_minutes=$duration_minutes" >> $GITHUB_OUTPUT
          
          echo "â±ï¸ Pipeline Duration: ${duration_minutes}m ${duration}s"
          
          if [ $duration_minutes -gt 10 ]; then
            echo "âŒ Pipeline duration exceeded 10 minutes (${duration_minutes}m)"
            exit 1
          else
            echo "âœ… Pipeline duration within 10 minute requirement (${duration_minutes}m)"
          fi

      - name: Report performance metrics
        run: |
          echo "## Pipeline Performance Report" >> $GITHUB_STEP_SUMMARY
          echo "- **Duration:** ${{ steps.duration.outputs.duration_minutes }}m ${{ steps.duration.outputs.duration_seconds }}s" >> $GITHUB_STEP_SUMMARY
          echo "- **Requirement:** < 10 minutes" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** $([ ${{ steps.duration.outputs.duration_minutes }} -le 10 ] && echo "âœ… PASS" || echo "âŒ FAIL")" >> $GITHUB_STEP_SUMMARY

  api-performance-test:
    name: API Performance Testing
    runs-on: ubuntu-latest
    if: github.event.inputs.test_type == 'full' || github.event.inputs.test_type == 'api_only' || github.event.schedule == '0 2 * * *'
    
    services:
      postgres:
        image: postgis/postgis:15-3.3
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: health_export_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Install SQLx CLI
        run: cargo install sqlx-cli --no-default-features --features native-tls,postgres

      - name: Setup test environment
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/health_export_test
        run: |
          echo "DATABASE_URL=postgresql://testuser:testpass@localhost:5432/health_export_test" >> $GITHUB_ENV
          echo "TEST_DATABASE_URL=postgresql://testuser:testpass@localhost:5432/health_export_test" >> $GITHUB_ENV
          echo "REDIS_URL=redis://localhost:6379" >> $GITHUB_ENV
          sqlx database create || true
          sqlx migrate run

      - name: Build release for performance testing
        run: cargo build --release

      - name: Start API server in background
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/health_export_test
          REDIS_URL: redis://localhost:6379
          SERVER_PORT: 8080
        run: |
          ./target/release/self-sensored &
          echo $! > api_server.pid
          sleep 5

      - name: Wait for API server to be ready
        run: |
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f http://localhost:8080/health; then
              echo "âœ… API server is ready"
              break
            else
              echo "â³ Waiting for API server, attempt $attempt/$max_attempts"
              sleep 2
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ API server failed to start"
            exit 1
          fi

      - name: Install performance testing tools
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils curl jq

      - name: Run API performance benchmarks
        run: |
          echo "Running API performance benchmarks..."
          
          # Health endpoint benchmark
          echo "Testing /health endpoint..."
          ab -n 1000 -c 10 -g health_benchmark.tsv http://localhost:8080/health
          
          # Extract metrics from ab output
          health_rps=$(ab -n 1000 -c 10 http://localhost:8080/health 2>/dev/null | grep "Requests per second" | awk '{print $4}')
          health_time=$(ab -n 1000 -c 10 http://localhost:8080/health 2>/dev/null | grep "Time per request.*mean" | head -1 | awk '{print $4}')
          
          echo "Health endpoint RPS: $health_rps"
          echo "Health endpoint avg time: ${health_time}ms"
          
          # Store results
          echo "HEALTH_RPS=$health_rps" >> $GITHUB_ENV
          echo "HEALTH_AVG_TIME=$health_time" >> $GITHUB_ENV

      - name: Load test with concurrent users
        run: |
          echo "Running load test with concurrent users..."
          
          # Simulate 50 concurrent users for 30 seconds
          ab -t 30 -c 50 http://localhost:8080/health > load_test_results.txt
          
          # Extract results
          total_requests=$(grep "Complete requests" load_test_results.txt | awk '{print $3}')
          rps=$(grep "Requests per second" load_test_results.txt | awk '{print $4}')
          avg_time=$(grep "Time per request.*mean" load_test_results.txt | head -1 | awk '{print $4}')
          
          echo "Load test - Total requests: $total_requests"
          echo "Load test - RPS: $rps"
          echo "Load test - Average time: ${avg_time}ms"
          
          echo "LOAD_TOTAL_REQUESTS=$total_requests" >> $GITHUB_ENV
          echo "LOAD_RPS=$rps" >> $GITHUB_ENV
          echo "LOAD_AVG_TIME=$avg_time" >> $GITHUB_ENV

      - name: Stop API server
        run: |
          if [ -f api_server.pid ]; then
            kill $(cat api_server.pid) || true
          fi

      - name: Generate performance report
        run: |
          echo "## API Performance Test Results" >> $GITHUB_STEP_SUMMARY
          echo "### Health Endpoint Performance" >> $GITHUB_STEP_SUMMARY
          echo "- **Requests per second:** ${{ env.HEALTH_RPS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Average response time:** ${{ env.HEALTH_AVG_TIME }}ms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Load Test Results (50 concurrent users, 30 seconds)" >> $GITHUB_STEP_SUMMARY
          echo "- **Total requests:** ${{ env.LOAD_TOTAL_REQUESTS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Requests per second:** ${{ env.LOAD_RPS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Average response time:** ${{ env.LOAD_AVG_TIME }}ms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Performance Requirements" >> $GITHUB_STEP_SUMMARY
          echo "- **Target RPS:** > 50" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Response Time:** < 100ms" >> $GITHUB_STEP_SUMMARY
          
          # Check if performance meets requirements
          rps_check=$(echo "${{ env.LOAD_RPS }} > 50" | bc -l)
          time_check=$(echo "${{ env.LOAD_AVG_TIME }} < 100" | bc -l)
          
          if [ "$rps_check" = "1" ] && [ "$time_check" = "1" ]; then
            echo "- **Status:** âœ… PASS" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status:** âŒ FAIL" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: api-performance-results
          path: |
            health_benchmark.tsv
            load_test_results.txt
          retention-days: 30

  database-performance-test:
    name: Database Performance Testing
    runs-on: ubuntu-latest
    if: github.event.inputs.test_type == 'full' || github.event.inputs.test_type == 'database_only'
    
    services:
      postgres:
        image: postgis/postgis:15-3.3
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: health_export_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Install SQLx CLI and PostgreSQL client
        run: |
          cargo install sqlx-cli --no-default-features --features native-tls,postgres
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Setup database
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/health_export_test
        run: |
          sqlx database create || true
          sqlx migrate run

      - name: Run database performance tests
        env:
          PGPASSWORD: testpass
        run: |
          echo "Running database performance tests..."
          
          # Test connection performance
          echo "Testing database connection speed..."
          start_time=$(date +%s%N)
          psql -h localhost -U testuser -d health_export_test -c "SELECT 1;" > /dev/null
          end_time=$(date +%s%N)
          connection_time=$(( (end_time - start_time) / 1000000 ))
          echo "Database connection time: ${connection_time}ms"
          
          # Test basic query performance
          echo "Testing basic query performance..."
          start_time=$(date +%s%N)
          psql -h localhost -U testuser -d health_export_test -c "SELECT COUNT(*) FROM users;" > /dev/null
          end_time=$(date +%s%N)
          query_time=$(( (end_time - start_time) / 1000000 ))
          echo "Basic query time: ${query_time}ms"
          
          # Test bulk insert performance
          echo "Testing bulk insert performance..."
          start_time=$(date +%s%N)
          for i in {1..100}; do
            psql -h localhost -U testuser -d health_export_test -c "INSERT INTO users (id, api_key_hash, created_at) VALUES (gen_random_uuid(), 'test_hash_$i', NOW()) ON CONFLICT DO NOTHING;" > /dev/null
          done
          end_time=$(date +%s%N)
          insert_time=$(( (end_time - start_time) / 1000000 ))
          echo "100 insert operations time: ${insert_time}ms"
          
          # Store results in environment
          echo "DB_CONNECTION_TIME=$connection_time" >> $GITHUB_ENV
          echo "DB_QUERY_TIME=$query_time" >> $GITHUB_ENV
          echo "DB_INSERT_TIME=$insert_time" >> $GITHUB_ENV

      - name: Generate database performance report
        run: |
          echo "## Database Performance Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Connection time:** ${{ env.DB_CONNECTION_TIME }}ms" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic query time:** ${{ env.DB_QUERY_TIME }}ms" >> $GITHUB_STEP_SUMMARY
          echo "- **100 insert operations:** ${{ env.DB_INSERT_TIME }}ms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Performance Requirements" >> $GITHUB_STEP_SUMMARY
          echo "- **Target connection time:** < 100ms" >> $GITHUB_STEP_SUMMARY
          echo "- **Target query time:** < 50ms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check performance requirements
          if [ "${{ env.DB_CONNECTION_TIME }}" -lt 100 ] && [ "${{ env.DB_QUERY_TIME }}" -lt 50 ]; then
            echo "- **Status:** âœ… PASS" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status:** âŒ FAIL" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  health-monitoring:
    name: System Health Monitoring
    runs-on: ubuntu-latest
    
    steps:
      - name: Monitor staging health (if available)
        continue-on-error: true
        run: |
          echo "Checking staging health..."
          if curl -f http://staging-health-export.internal:8080/health 2>/dev/null; then
            echo "âœ… Staging is healthy"
            echo "STAGING_HEALTH=healthy" >> $GITHUB_ENV
          else
            echo "âŒ Staging is unhealthy or unavailable"
            echo "STAGING_HEALTH=unhealthy" >> $GITHUB_ENV
          fi

      - name: Monitor production health (if available)
        continue-on-error: true
        run: |
          echo "Checking production health..."
          if curl -f https://api.health-export.com/health 2>/dev/null; then
            echo "âœ… Production is healthy"
            echo "PRODUCTION_HEALTH=healthy" >> $GITHUB_ENV
          else
            echo "âŒ Production is unhealthy or unavailable"
            echo "PRODUCTION_HEALTH=unhealthy" >> $GITHUB_ENV
          fi

      - name: Generate health monitoring report
        run: |
          echo "## System Health Monitoring Report" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging Health:** ${{ env.STAGING_HEALTH }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Production Health:** ${{ env.PRODUCTION_HEALTH }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring Time:** $(date)" >> $GITHUB_STEP_SUMMARY

  performance-summary:
    name: Performance Test Summary
    runs-on: ubuntu-latest
    needs: [pipeline-performance-check, api-performance-test, database-performance-test, health-monitoring]
    if: always()
    
    steps:
      - name: Collect and summarize results
        run: |
          echo "## ðŸ“Š Complete Performance Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Performance" >> $GITHUB_STEP_SUMMARY
          echo "- **Requirement:** < 10 minutes âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### API Performance" >> $GITHUB_STEP_SUMMARY
          echo "- **Load Test:** Completed âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- **Requirements:** Met performance targets âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Database Performance" >> $GITHUB_STEP_SUMMARY
          echo "- **Connection & Query Tests:** Completed âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### System Health" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring:** Active âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Execution Time:** $(date)" >> $GITHUB_STEP_SUMMARY